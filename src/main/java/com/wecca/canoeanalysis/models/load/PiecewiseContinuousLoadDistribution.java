package com.wecca.canoeanalysis.models.load;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.wecca.canoeanalysis.aop.Traceable;
import com.wecca.canoeanalysis.models.function.BoundedUnivariateFunction;
import com.wecca.canoeanalysis.models.function.CubicBezierFunction;
import com.wecca.canoeanalysis.models.function.Section;
import com.wecca.canoeanalysis.models.canoe.Hull;
import com.wecca.canoeanalysis.utils.CalculusUtils;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.Setter;
import org.apache.commons.math3.optim.MaxEval;
import java.util.*;

@Getter @Setter @EqualsAndHashCode(callSuper = true)
public class PiecewiseContinuousLoadDistribution extends LoadDistribution {

    @JsonProperty("pieces")
    protected TreeMap<Section, BoundedUnivariateFunction> pieces;

    public PiecewiseContinuousLoadDistribution(LoadType type, List<BoundedUnivariateFunction> pieces, List<Section> subSections) {
        super(type, new Section(CalculusUtils.roundXDecimalDigits(subSections.getFirst().getX(), 10), subSections.getLast().getRx()));
        CalculusUtils.validatePiecewiseContinuity(pieces, subSections);
        this.pieces = new TreeMap<>(Comparator.comparingDouble(Section::getX));
        for (int i = 0; i < pieces.size(); i++) {
            this.pieces.put(subSections.get(i), pieces.get(i));
        }
    }

    /**
     * Factory method to create a self-weight distribution from a hull with the new model.
     * Here the hull’s self-weight distribution is built by partitioning the full weight function
     * over each side–view segment (each representing a section).
     * @param hull the hull to get the self-weight distribution of
     * @return the resulting PiecewiseContinuousLoadDistribution representing the self weight (in kN/m)
     */
    public static PiecewiseContinuousLoadDistribution fromHull(Hull hull) {
        // Use the side-view segments as the partitioning for the hull.
        List<CubicBezierFunction> sideSegments = hull.getSideViewSegments();
        List<Section> sections = new ArrayList<>();
        List<BoundedUnivariateFunction> pieces = new ArrayList<>();

        // The overall weight distribution function is defined over the full hull.
        BoundedUnivariateFunction weightFunc = hull.getWeightDistributionFunction();

        // For each side-view segment, restrict weightFunc to that segment's x-domain.
        for (CubicBezierFunction seg : sideSegments) {
            Section sec = new Section(seg.getX1(), seg.getX2());
            sections.add(sec);
            pieces.add(new BoundedUnivariateFunction() {
                @Override
                public double value(double x) {return weightFunc.value(x);}
                @Override
                public double getMaxValue(Section s) {return weightFunc.getMaxValue(s);}
                @Override
                public double getMinValue(Section s) {return weightFunc.getMinValue(s);}
            });
        }
        return new PiecewiseContinuousLoadDistribution(LoadType.HULL, pieces, sections);
    }

    /**
     * @return the function with pieces stitched together into one function
     */
    @JsonIgnore
    public BoundedUnivariateFunction getPiecedFunction() {
        return x -> {
            double tolerance = 1e-10;
            for (Map.Entry<Section, BoundedUnivariateFunction> entry : pieces.entrySet()) {
                Section interval = entry.getKey();
                if (x >= interval.getX() - tolerance && x <= interval.getRx() + tolerance) return entry.getValue().value(x);
            }
            throw new IllegalArgumentException("x value: " + x + " is out of bounds for the distribution");
        };
    }

    /**
     * @return the integral over the distribution, a force in kN
     */
    @Override
    public double getForce() {
        return pieces.entrySet().stream().mapToDouble
                (piece -> CalculusUtils.integrator.integrate(MaxEval.unlimited().getMaxEval(),
                        piece.getValue(), piece.getKey().getX(), piece.getKey().getRx())).sum();
    }

    @Override
    public double getX() {
        return getSection().getX();
    }

    /**
     * @return the signed maximum absolute value (i.e. the lowest minimum or highest maximum) of the distribution, in kN/m
     */
    @Override
    public double getMaxSignedValue() {
        return getPiecedFunction().getMaxSignedValue(section);
    }

    @JsonIgnore
    public Section getSection() {
        return new Section(pieces.firstKey().getX(), pieces.lastKey().getRx());
    }

    /**
     * Calculates the moment generated by the piecewise load about (x = rotationX, y = 0).
     * @param rotationX the x co-ordinate of the point of rotation
     * @return the moment, the integral of Force * (x - rotationX) over the distribution.
     */
    @Override @Traceable
    public double getMoment(double rotationX) {
        return pieces.entrySet().stream().mapToDouble(piece ->
                CalculusUtils.integrator.integrate(MaxEval.unlimited().getMaxEval(),
                x -> piece.getValue().value(x) * (x - rotationX),
                piece.getKey().getX(), piece.getKey().getRx())
        ).sum();
    }
}
